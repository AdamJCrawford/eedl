# -*- coding: utf-8 -*-import arcpyimport osfrom functools import wrapsdef parameters_as_dict(f):    """    A Decorator for ArcGIS Python toolbox tools (their execute function) that makes the "parameters" parameter'    into a dictionary indexed by parameter name.    """    @wraps(f)    def wrapper(*args, **kwargs):        params = args[1]        parameters = {}        for param in params:            parameters[param.name] = param        f(self=args[0], parameters=parameters, messages=args[1])    return wrapperclass Toolbox(object):    def __init__(self):            """Define the toolbox (the name of the toolbox is the name of the            .pyt file)."""            self.label = "Fallow Classification Toolbox"            self.alias = "FallowClassificationToolbox"            # List of tool classes associated with this toolbox            self.tools = [PreprocessYearTool]class PreprocessYearTool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Preprocess RF Data"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        input_features = arcpy.Parameter(            name="input_features",            displayName="Input LandIQ Fields",            direction="Input",            datatype="GPFeatureLayer",        )        id_field = arcpy.Parameter(            name="id_field",            displayName="Land IQ ID Field",            direction="Input",            datatype="Field",        )        id_field.parameterDependencies = [input_features.name]        id_field.value = "UniqueID"                early_season_min_raster = arcpy.Parameter(            name="early_season_min_raster",            displayName="Early-Season Min Raster",            direction="Input",            datatype="GPRasterLayer",        )                early_season_max_raster = arcpy.Parameter(            name="early_season_max_raster",            displayName="Early-Season Max Raster",            direction="Input",            datatype="GPRasterLayer",        )        mid_season_min_raster = arcpy.Parameter(            name="mid_season_min_raster",            displayName="Mid-Season Min Raster",            direction="Input",            datatype="GPRasterLayer",        )        mid_season_max_raster = arcpy.Parameter(            name="mid_season_max_raster",            displayName="Mid-Season Max Raster",            direction="Input",            datatype="GPRasterLayer",        )        late_season_min_raster = arcpy.Parameter(            name="late_season_min_raster",            displayName="Late-Season Min Raster",            direction="Input",            datatype="GPRasterLayer",        )        late_season_max_raster = arcpy.Parameter(            name="late_season_max_raster",            displayName="Late-Season Max Raster",            direction="Input",            datatype="GPRasterLayer",        )                year = arcpy.Parameter(            name="year",            displayName="Year",            direction="Input",            datatype="GPString",        )        year.value = 2022                output_features = arcpy.Parameter(            name="output_features",            displayName="Output LandIQ Fields",            direction="Output",            datatype="GPFeatureLayer",        )                params = [input_features, id_field,         early_season_min_raster, early_season_max_raster,         mid_season_min_raster, mid_season_max_raster,         late_season_min_raster, late_season_max_raster,         year, output_features]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return            @parameters_as_dict    def execute(self, parameters, messages):        """The source code of the tool."""                arcpy.AddToolbox('AttachRasterDataToPolygons.pyt')        # Copy the input features to an output we'll work with - filter out the urban areas in the process        base_features = parameters['input_features'].valueAsText        #output_features = arcpy.CreateScratchName("classification_preprocessing")        #out_gdb, out_name = os.path.split(output_features)        output_features = parameters['output_features'].valueAsText        out_gdb, out_name = os.path.split(output_features)               arcpy.AddMessage("Copying inputs")        # make a copy of the input to the output so we don't modify the input. Filter out Urban areas at the same time with a SQL expression        arcpy.FeatureClassToFeatureClass_conversion(base_features, out_gdb, out_name, "CLASS2 not in ('U', ' U')")                arcpy.AddMessage("Adding Latitude Field")        # Calculate a latitude field with Calculate Geometry Attributes0        arcpy.management.CalculateGeometryAttributes(output_features, [["latitude", "CENTROID_Y"]], coordinate_system=arcpy.SpatialReference(4326), coordinate_format='DD')        #arcpy.management.AddField(output_features, "latitude", "DOUBLE")        #arcpy.management.CalculateField(output_features, "latitude", "!Shape!.projectAs(spatial_ref).centroid.Y", "Python3", "spatial_ref = arcpy.SpatialReference(4326)")                arcpy.AddMessage("Adding Fallow Field for Training Year")        # calculate a field is_fallow that separates the land use classes into known fallow and not fallow        arcpy.management.AddField(output_features, "is_fallow_training", "LONG")        arcpy.management.CalculateField(output_features, "is_fallow", "!CLASS2! in ('X', ' X', 'I', ' I')")        season_data = [            "early_season_min_raster",            "early_season_max_raster",            "mid_season_min_raster",            "mid_season_max_raster",            "late_season_min_raster",            "late_season_max_raster"        ]        for season in season_data:            arcpy.AddMessage(f"Running Zonal Stats for {season}")            # run zonal stats on the summer data (Mean/STDDev)            # rename the fields in the output to something we can use            # join them back to the input data            season_name = season.replace("_season_min_raster", "_ssn_min").replace("_season_max_raster", "_ssn_max")            arcpy.AttachDataFieldViaZonalStats_AttachRasterToPolygons(                output_features,                "UniqueID",                parameters[season].valueAsText,                f"{season_name}_{parameters['year'].valueAsText}",                "MEAN_STD"            )                parameters['output_features'].values = output_features        return output_features    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return